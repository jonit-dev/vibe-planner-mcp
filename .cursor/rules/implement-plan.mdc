---
description: 
globs: 
alwaysApply: false
---
# Implement Plan

This rule provides a structured approach for implementing plans documented in markdown files, focusing on iterative implementation, thorough testing, and methodical progress.

## Warning
DO NOT EDIT THIS FILE. MD SHOULD COME IN A NEW .md FILE!

## Process Overview

1. **Understand the full plan** before starting implementation
2. **Break the plan into logical steps** that can be implemented independently
3. **Implement one step at a time**, testing after each step
4. **Commit working changes** after each successful step
5. **Review implementation** when all steps are complete

## Implementation Workflow

```mermaid
flowchart TD
    A[Understand Full Plan] --> B[Break Into Logical Steps]
    B --> C[Start First Step]
    C --> D[Locate Relevant Code]
    D --> E[Make Changes]
    E --> F[Update Tests]
    F --> G1[Run Type-checking]
    G1 -->|Fails| E
    G1 -->|Passes| G2[Run Contextual Tests]
    G2 -->|Tests Pass| H[Commit Changes]
    G2 -->|Tests Fail| E
    H --> I{More Steps?}
    I -->|Yes| J[Move to Next Step]
    J --> D
    I -->|No| K[Review Implementation]
    K --> L[Check Against Plan]
    L --> M{Implementation Complete?}
    M -->|Yes| N[Final Commit]
    M -->|No| O[Identify Gaps]
    O --> D
```

## Step-by-Step Approach

1. **Analyze the current step**
   - Understand what needs to be changed
   - Identify all files that need modification
   - Plan test strategy for verifying changes

2. **Locate relevant code**
   - Search for related components, functions, or modules
   - Understand the existing implementation
   - Identify integration points and dependencies

3. **Make incremental changes**
   - Follow existing code patterns and style
   - Add clear comments explaining the changes
   - Keep changes focused on the current step only

4. **Update tests accordingly**
   - Modify existing tests to match new behavior
   - Add new tests for new functionality
   - Consider edge cases and error scenarios

5. **Run type-checking and linting**
   - Run the TypeScript compiler (`yarn tsc`)
   - Address any type errors or linting issues
   - Ensure code quality standards are met

6. **Run contextual tests only**
   - Test only the specific module or folder context
   - For example: `yarn jest src/providers/battle` if working on battle-related files
   - Or more specifically: `yarn jest relative/path/to/file.spec.ts`
   - Use test name patterns if needed: `yarn jest -t "test description"`
   - Focus on efficient testing of only what's changed
   - Avoid running the full test suite during development

7. **Commit completed step**
   - Stage all related changes in a single commit
   - Write clear, descriptive commit messages
   - Reference task/issue numbers if applicable

8. **Move to next step** and repeat the process

## Final Review

After implementing all steps:

1. **Verify implementation**
   - Run the type-checking: `yarn tsc`
   - Run contextual test suites for affected modules
   - Note: Comprehensive testing will be done manually later
   - Check for obvious regressions in modified components

2. **Review implementation against plan**
   - Check off each item in the plan
   - Verify nothing was missed
   - Review for edge cases

3. **Refine if needed**
   - Make any necessary adjustments
   - Re-test affected components
   - Commit final changes

## Best Practices

- Write clear comments explaining the rationale for changes
- Follow existing code patterns and conventions
- Keep commits atomic and focused on specific functionality
- Document any deviations from the original plan
- Create new tests for new functionality
- Test edge cases thoroughly
- Maintain backward compatibility where required
- Always run type-checking before committing
- Limit test runs to contextual folders (e.g., `yarn jest src/providers/battle`) 
- Only run specific tests to save time and resources
- Let comprehensive testing be done manually later

## Example Implementation Sequence

1. Read the entire plan first
2. Implement smallest logical unit (e.g., data model change)
3. Write/update tests for that unit
4. Run type-checking with `yarn tsc`
5. Verify functionality with contextual tests: `yarn jest src/module/path`
6. Commit that unit
7. Proceed to next logical unit (e.g., service layer)
8. After all units are implemented, review against plan
9. Address any identified gaps
10. Let comprehensive testing be done manually 
